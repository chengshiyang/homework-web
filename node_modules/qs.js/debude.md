## 具体应用场景

### 场景1：

vote按钮，点击一次之后，就不再接受事件，然后进入投票中的状态，ajax请求成功之后，显示成功，并进入禁用状态,ajax失败之后，显示再来一次。

平常写法
```
var $vote = $('#vote');
var $counter = $('#counter');


$vote.once('click', (e) => {
    $vote.attr('disabled', 'disabled');
    $vote.text('voting');
    $.ajax('/vote', res) => {
        $vote.text('vote succssfully');
        $counter.text(res);
    }, () => {
        $vote.text('vote failed, try again');
    });
});

```

使用qs的方式

```

var voteStream = qs('#vote').stream('click').take(1);

var vote = qs.stream((pipe){
    $.ajax("/vote", (res) => {
        pipe(res);
    }, () => {
        pipe(qs.Error());
    });
});

voteStream.assign('text', 'voting...') //改变按钮文案
    .assign('attr', 'disabled') //禁用按钮
    .awaiting(vote) //声明等待vote的处理
    .onValue((num) => {
        $('#vote').text("vote successfully");
        $('#counter').text(num); //如果成功改变投票数的值
    })
    .onError(() => {
        voteStream.text('vote failed, try again');
    });

```

从这个场景来看，使用qs代码量还变多了。


### 场景2

登录框，用户填写用户名和密码，两个其中一个为空，则登录按钮处于禁用状态，全部不为空时启用。

```
var $username = $('#username');
var $password = $('#password');
var $login = $('#login');
var username, password;

$username.on('input',  (e) => {
    username = e.target.value;
    updateButtonStatus();
});

$password.on('input',  (e) => {
    password = e.target.value;
    updateButtonStatus();
});


function updateButtonStatus() {
    if (username && password) {
        $login.attr('disabled', true);
    } else {
        $login.attr('disabled', false);
    }
}

```

使用qs

```
var username = qs('#username').stream('input').map( (e) => (e.target.value));
var password = qs('#password').stream('input').map( (e) => (e.target.value));
var loginEnable = username.and(password);

loginEnable.not().onValue($('#login'), 'attr', 'disabled');
```

这个场景代码量就变少了，是不是参与方越多，使用qs就会越加有利呢？是因为api对于逻辑有较大的帮助吗？

