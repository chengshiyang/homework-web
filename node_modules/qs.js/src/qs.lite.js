import './polyfill/bind';
import isFunction  from './polyfill/isFunction';
import toArray from './polyfill/toArray';
import {DROP_OLD} from './constants/common';
import Observable from './obserable';
import emitter from './emitter';
import extend from './polyfill/extend';
import Stream from './Stream';
import map from './functions/map';
import filter from './functions/filter';
import take from './functions/take';
import takeWhile from './functions/takeWhile';
import debounce from './functions/debounce';
import throttle from './functions/throttle';
import last from './functions/last';
import scan from './functions/scan';
import delay from './functions/delay';
import toProperty from './functions/toProperty';
import flatMap from './connect/flatMap';
import skip from './functions/skip';
import skipDuplicates from './functions/skipDuplicates';
import skipWhile from './functions/skipWhile';
import flatten from './functions/flatten';
import fromEvents from './functions/static/fromEvents';
import fromPromise  from './functions/static/fromPromise';

/**
 * qs 的默认调用会产生一个stream出来,
 */
function qs(fn) {
    return new Stream(fn);
}

/**
 * QS的静态方法
 *
 * 其中有
 *
 * 	- 时间函数如seq, interval,delay等
 * 	- 流的合并函数 merge, combine, zip
 */

qs.fromEvents = fromEvents;
qs.fromPromise = fromPromise;

//时间函数
qs.seq = require('./functions/time/seq');
qs.interval = require('./functions/time/interval');
qs.delay = require('./functions/time/delay');

//常量函数
qs.constant = require('./functions/constant');
qs.never = require('./functions/never');


/**
 * Prototype方法
 */
extend(Observable.prototype, {
    map(fn) {
        return map(this, fn);
    },

    filter(fn) {
        return filter(this, fn);
    },

    take(n) {
        return take(this, n);
    },

    takeWhile(fn) {
        return takeWhile(this, fn);
    },

    skip(n) {
        return skip(this, n);
    },

    skipWhile(fn) {
        return skipWhile(this, fn);
    },

    skipDuplicates(fn) {
        return skipDuplicates(this, fn);
    },

    debounce(wait, immediate) {
        return debounce(this, wait, immediate);
    },

    throttle(wait, leading, trailing) {
        return throttle(this, wait, leading, trailing);
    },

    flatten(fn) {
        return flatten(this, fn);
    },

    delay(time) {
        return delay(this, time);
    },

    toProperty(fn) {
        return toProperty(this, fn);
    },

    flatMap(fn) {
        return flatMap(this, fn);
    },

    flatMapFirst(fn) {
        return flatMap(this, fn, {obsLimit: 1});
    },

    flatMapLatest(fn) {
        return flatMap(this, fn, {obsLimit: 1, drop: DROP_OLD});
    },

    scan(fn, seed) {
        return scan(this, fn, seed);
    },

    last() {
        return last(this);
    },

    and(ob) {
        return combine([this, ob], (a, b) => a && b);
    },

    not() {
        return this.map(val => !val);
    },

});

module.exports = qs;
