'use strict';
var extend = require('extend');
var slice = [].slice;
var isFunction = require('./polyfill/isFunction');
var div = document.createElement('div');
var matchesSelector = ['moz', 'webkit', 'ms', 'o'].filter(function(prefix) {
    return prefix + 'MatchesSelector' in div;
})[0] + 'MatchesSelector';
var focusinSupported = 'onfocusin' in window;
var ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/;
var eventMethods = {
    preventDefault: 'isDefaultPrevented',
    stopImmediatePropagation: 'isImmediatePropagationStopped',
    stopPropagation: 'isPropagationStopped'
};
var returnTrue = function() { return true; },
    returnFalse = function() { return false; };



/**
 * delegate
 * 托管UI事件绑定
 * @private
 * @params {String} eventName
 * @params {String} selector
 * @params {Function} fn
 */
function delegate(el, eventName, selector, fn, context) {
    var delegator;
    if (isFunction(selector)) {
        fn = selector;
        context = fn;
    }
    delegator = selector ? function(ev) {
        var target = ev.target,
            evProxy;
        //定位被托管节点
        while (target && target !== this &&
                !target[matchesSelector](selector)) {
            target = target.parentNode;
        }
        if (target && target !== this) {
            evProxy = extend(createProxy(ev), {currentTarget: target});
            return fn.apply(context,
                    [evProxy, el].concat(slice.call(arguments, 1)));
        }
    } : function (ev) {
        var target = ev.target;
        var evProxy = extend(createProxy(ev), {currentTarget: target});
        return fn.apply(context, [evProxy, el].concat(slice.call(arguments, 1)));
    };
    el.addEventListener(
        eventName,
        delegator,
        eventCapture(eventName)
    );
}

/**
 * blur event
 */
function eventCapture(e) {
    return !focusinSupported && (e in focus);
}


/**
 * 创建事件代理
 * 由于事件机制中的Event变量是只读的，但是托管（delegate）的时候需要修改
 * currentTarget,所以只能创建事件代理，这个代理中又所有的event属性
 */
function createProxy(ev) {
    var key, proxy = {
            originalEvent: ev
        };
    for (key in ev) {
        if (!ignoreProperties.test(key) && ev[key] !== undefined) {
            proxy[key] = ev[key];
        }
    }
    return compatible(proxy, ev);
}


function compatible(ev, source) {
    var name, predicate, sourceMethod;
    function method() {
        this[predicate] = returnTrue;
        return sourceMethod && sourceMethod.apply(source, arguments);
    }
    if (source || !ev.isDefaultPrevented) {
        source || (source = ev);
        for (predicate in eventMethods) {
            if (!eventMethods.hasOwnProperty(predicate)) { continue; }
            name = eventMethods[predicate];
            sourceMethod = source[name];
            ev[name] = method;
            ev[predicate] = returnFalse;
        }

        if (source.defaultPrevented !== undefined ?
                source.defaultPrevented :
                'returnValue' in source ?
                        source.returnValue === false :
                        source.getPreventDefault &&
                        source.getPreventDefault()) {
                ev.isDefaultPrevented = returnTrue;
        }
    }
    return ev;
}

module.exports = delegate;