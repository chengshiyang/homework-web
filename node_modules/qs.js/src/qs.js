import './polyfill/bind';
import isFunction  from './polyfill/isFunction';
import toArray from './polyfill/toArray';
import {DROP_OLD} from './constants/common';
import Observable from './obserable';
import emitter from './emitter';
import extend from './polyfill/extend';
import Stream from './Stream';
import map from './functions/map';
import mapError from './functions/mapError';
import filter from './functions/filter';
import take from './functions/take';
import takeWhile from './functions/takeWhile';
import debounce from './functions/debounce';
import throttle from './functions/throttle';
import last from './functions/last';
import scan from './functions/scan';
import delay from './functions/delay';
import window from './functions/window';
import awaiting from './connect/awaiting';
import toProperty from './functions/toProperty';
import flatMap from './connect/flatMap';
import combine from './connect/combine';
import merge from './connect/merge';
import buffer from './connect/buffer';
import skip from './functions/skip';
import skipDuplicates from './functions/skipDuplicates';
import skipWhile from './functions/skipWhile';
import flatten from './functions/flatten';
import fromEvents from './functions/static/fromEvents';
import fromPromise  from './functions/static/fromPromise';


const methodMap = {
    'text': 'innerText',
    'html': 'innerHTML'
};


/**
 * qs 的默认调用会产生一个stream出来,
 */
function qs(fn) {
    return new Stream(fn);
}

/**
 * QS的静态方法
 *
 * 其中有
 *
 * 	- 时间函数如seq, interval,delay等
 * 	- 流的合并函数 merge, combine, zip
 */

qs.fromEvents = fromEvents;
qs.fromPromise = fromPromise;

//时间函数
qs.seq = require('./functions/time/seq');
qs.interval = require('./functions/time/interval');
qs.delay = require('./functions/time/delay');

//流合并函数
qs.merge = merge;
qs.combine = combine;
qs.zip = require('./connect/zip');

//常量函数
qs.constant = require('./functions/constant');
qs.never = require('./functions/never');


/**
 * Prototype方法
 */
extend(Observable.prototype, {
    map(fn) {
        return map(this, fn);
    },

    mapError(fn) {
        return mapError(ob, fn);
    },

    filter(fn) {
        return filter(this, fn);
    },

    take(n) {
        return take(this, n);
    },

    takeWhile(fn) {
        return takeWhile(this, fn);
    },

    assign(el, method) {
        return this.onValue( val => {
            el[method] = val;
        });
    },

    skip(n) {
        return skip(this, n);
    },

    skipWhile(fn) {
        return skipWhile(this, fn);
    },

    skipDuplicates(fn) {
        return skipDuplicates(this, fn);
    },

    debounce(wait, immediate) {
        return debounce(this, wait, immediate);
    },

    throttle(wait, leading, trailing) {
        return throttle(this, wait, leading, trailing);
    },

    flatten(fn) {
        return flatten(this, fn);
    },

    delay(time) {
        return delay(this, time);
    },

    toProperty(fn) {
        return toProperty(this, fn);
    },

    flatMap(fn) {
        return flatMap(this, fn);
    },

    flatMapFirst(fn) {
        return flatMap(this, fn, {obsLimit: 1});
    },

    flatMapLatest(fn) {
        return flatMap(this, fn, {obsLimit: 1, drop: DROP_OLD});
    },

    combine(ob, combinator) {
        return combine([this, ob], combinator);
    },

    merge(ob) {
        return merge([this, ob]);
    },

    buffer(ob) {
        return buffer(this, ob);
    },

    scan(fn, seed) {
        return scan(this, fn, seed);
    },

    last() {
        return last(this);
    },

    awaiting(ob) {
        return awaiting(this, ob);
    },

    and(ob) {
        return combine([this, ob], (a, b) => a && b);
    },

    not() {
        return this.map(val => !val);
    },

    pluck() {
        let args = toArray(arguments);
        let getVal = (v) => {
            for (let i = 0, len = args.length; i < len; i++) {
                v = v[args[i]];
            }
            return v;
        }
        return this.map((e) => {
            return getVal(e);
        });
    },

    window(size) {
        return window(this, { size });
    }
});

module.exports = qs;
