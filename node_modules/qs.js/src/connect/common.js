import Stream from '../Stream';
import extend from '../polyfill/extend';
import {VALUE, ANY, END, ERROR} from '../constants/events';
import {forEach, concat, findBy, remove} from '../polyfill/list';
import {DROP_OLD} from '../constants/common';
const NO_LIMIT = -1;

const id = x => x;
function ConnectCommon(options) {
    Stream.call(this);
    this.init(options);
}

ConnectCommon.prototype = Object.create(Stream.prototype);

extend(ConnectCommon.prototype, {
    init({obsLimit = NO_LIMIT, drop} = {}) {
        this._obs = [];
        this._obsLimit = obsLimit;
        this._drop = drop;
        this._endHandlers = [];
        this._$handleAny = (e) => this._handleAny(e);
    },

    _handleAny(e) {
        switch(e.type) {
            case VALUE: return this.emitValue(e.value);
            case ERROR: return this.emitError(e.value);
        }
    },

    _addAll(obs){
        forEach(obs, ob => this._add(ob));
    },

    _add(ob, transformer = id) {
        const obsLimit = this._obsLimit;
        if (obsLimit === NO_LIMIT || this._obs.length < obsLimit) {
            //如果没有限制， 或者没有超出监听队列的限制, 则继续添加监听
            this._addToObs(transformer(ob));
        } else {
            //如果超出，且允许移除最旧的spawn的流，则移除之后，然后spawn出新的流
            //不允许移除的话，则什么都不做, 这种情况就类似与，直到上一个流结束，才能够添加新的流，可以实现flatMapFirst()的效果
            if (this._drop === DROP_OLD) {
                this._removeFromObs(this._obs[0]);
                //继续调用添加接口，直到可以加入为止。
                this._add(ob, transformer);
            }
        }
    },

    _addToObs(ob) {
        if (this.state.active) {
            let e = ob._currentEvent;
            if (!ob.state.alive) {
                if (ob._currentEvent) { this.emit(e.type, e.value); }
                return;
            }
            this._obs = concat(this._obs, [ob]);
            this._subscribe(ob);
        } else {
            this._obs = concat(this._obs, [ob]);
        }
    },

    _onActivation() {
        forEach(this._obs, (ob) => this._subscribe(ob));
    },

    _onDeactivation() {
        forEach(this._obs, (ob) => this._unsubscribe(ob));
    },

    _subscribe(ob) {
        ob.onAny(this._$handleAny);
        //在上面这个步骤状态可能会变为inactive, 这样子，就没有必要监听End事件
        if (this.state.active) {
            this._subEndOf(ob);
        }
    },

    _unsubscribe(ob) {
        ob.offAny(this._$handleAny);
        this._unsubEndOf(ob);
    },

    _subEndOf(ob) {
        const endHandler = () => this._removeFromObs(ob);
        this._endHandlers.push({ob: ob, handler: endHandler});
        ob.onEnd(endHandler);
    },

    _unsubEndOf(ob) {
        var index = findBy(this._endHandlers, (ed) => ed.ob === ob);
        if (index !== -1) {
            ob.offEnd(this._endHandlers[index].handler);
            this._endHandlers = remove(this._endHandlers, index);
        }
    },

    _removeFromObs(ob) {
        //active状态下才需要unsub,如果是inative的时候，由于没有sub过，也就无需unsub了
        if (this.state.active) {
            this._unsubscribe(ob);
        }
        var index = findBy(this._obs, (item) => item === ob);
        this._obs = remove(this._obs, index);
        if (index !== -1) {
            //如果监听的所有observer都已经结束了，那么merge流也可以结束了.
            if (this._isEnd()) {
                this._onEnd();
            }
        }
        return index;
    },

    _isEnd() {
        return  this._obs.length === 0;
    },

    _clear(){
        Stream.prototype._clear.call(this);
        this._obs = null;
        this._$handleAny = null;
        this._endHandlers = null;
    }
});

export default ConnectCommon;