import Stream from '../Stream';
import extend from '../polyfill/extend';
import never from '../functions/never';
import {VALUE, ANY, END} from '../constants/events';
import {M_NULL} from '../constants/common';
import {forEach, concat, findBy, remove, fill} from '../polyfill/list';




function Combine(obs, passive, combinator) {
    Stream.call(this);
    this._obsCount = obs.length;
    this._sources = concat(obs, passive);
    this._combinator = combinator || (x => x);
    let len = this._sources.length;
    this._lastestValues = new Array(len);
    this._aliveCount = 0;
    fill(this._lastestValues, M_NULL);
    this._$handlers = [];
    forEach(this._sources, (source, i) => {
        this._$handlers.push((e) => this._handleAny(e, i));
    });
}

Combine.prototype = Object.create(Stream.prototype);

extend(Combine.prototype, {
    _name: 'combine',

    _onActivation () {
        let sourceLen = this._sources.length;
        this._aliveCount = this._obsCount;
        //先处理passive流先, 防止当两个流同一时刻发出的时候（同步），能够保证_emitValueIfReady的正常运行
        for (let i = this._aliveCount; i < sourceLen; i++) {
            this._sources[i].onAny(this._$handlers[i]);
        }
        for (let i = 0; i < this._aliveCount; i++) {
            this._sources[i].onAny(this._$handlers[i]);
        }
    },

    _onDeactivation() {
        forEach(this._sources, (source, i) => {
            source.offAny(this._$handlers[i]);
        });
    },

    _handleAny(e, sourceIndex) {
        let type = e.type;
        if (type === VALUE) {
            this._lastestValues[sourceIndex] = e.value;
            if (this._isBelongToObs(sourceIndex)) {
                //如果是属于obs流，而不是passive流的话, obsCount之后的坐标都是passive的值了
                this._emitValueIfReady();
            }
        } else if (type === END) {
            if (this._isBelongToObs(sourceIndex)) {
                this._aliveCount--;//如果combind([a,b,...])的多个流中，结束的，则_aliveCount--。
                if (this._aliveCount === 0) {
                    this.emitEnd();
                }
            }
        }
    },

    _isBelongToObs(index){
        return index < this._obsCount;
    },

    _emitValueIfReady() {
        var ready = true;
        forEach(this._lastestValues, (val) => {
            if (val === M_NULL) {
                ready = false;
            }
        });
        if (ready) {
            this.emitValue(this._combinator.apply(this, this._lastestValues));
        }
    },

    _clear() {
        Stream.prototype._clear.call(this);
        this._sources = null;
        this._combinator = null
        this._lastestValues = null;
        this._$handlers = null;
    }
});

module.exports = function combine(obs, passive, combinator) {
    if (typeof passive === 'function') {
        combinator = passive;
        passive = [];
    }
    if (!combinator) {
        throw new Error('need combinator for combine');
    }
    return obs.length === 0 ? never() : new Combine(obs, passive, combinator);
};