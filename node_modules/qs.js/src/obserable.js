import extend from './polyfill/extend';
import {Dispatcher, callSubcribers} from './dispatcher';
import {VALUE, END, ANY, ERROR} from './constants/events';

function Observable() {
    this._dispatcher = new Dispatcher();
    this.state = {
        alive: true,
        active: false
    };
}


extend(Observable.prototype, {
    _name: 'obserable',

    setState(name, value) {
        this.state[name] = value;
    },

    _onActivation() {},
    _onDeactivation() {},

    emit(type, v) {
        switch(type) {
            case VALUE: return this.emitValue(v);
            case ERROR: return this.emitError(x);
            case END: return this.emitEnd();
        }
    },

    emitValue(value) {
        if (this.state.alive) {
            this._dispatcher.dispatch({type: VALUE, value}, this);
        }
    },

    emitEnd() {
        if (this.state.alive) {
            this.setState('alive', false);
            this._dispatcher.dispatch({type: END}, this);
            this._clear();
        }
    },

    emitError(value) {
        if (this.state.alive) {
            this._dispatcher.dispatch({type: ERROR, value});
        }
    },

    onValue(fn) {
        return this._on(VALUE, fn);
    },

    offValue(fn) {
        return this._off(VALUE, fn);
    },

    onEnd(fn) {
        return this._on(END, fn);
    },

    offEnd(fn) {
        return this._off(END, fn);
    },

    onAny(fn) {
        return this._on(ANY, fn);
    },

    offAny(fn) {
        return this._off(ANY, fn);
    },

    onError(fn) {
        return this._on(ERROR, fn);
    },

    offError(fn) {
        return this._off(ERROR, fn);
    },

    _on(type, fn) {
        if (this.state.alive) {
            this._dispatcher.add(type, fn);
            this._setActive(true);
        } else {
            callSubcribers(type, fn, {type: END});
        }
        return this;
    },

    _off(type, fn) {
        if (this.state.alive) {
            let count = this._dispatcher.remove(type, fn);
            if (count === 0) {
                this._setActive(false);
            }
        }
        return this;
    },

    _setActive(active) {
        if (this.state.active !== active) {
            this.setState('active', active);
            if (active) {
                //激活
                this._activating = true;
                this._onActivation();
                this._activating = false;
            } else {
                this._onDeactivation();
            }
        }
    },

    _clear() {
        this._setActive(false);
        this._dispatcher.cleanup();
        this._dispatcher = null;
    },

    _ofSameType(A, B) {
        return A.prototype.getType() === this.getType() ? A : B;
    }
});


export default Observable;